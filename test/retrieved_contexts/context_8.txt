[page 18] ính**


Tiếp theo, chúng ta sẽđịnh nghĩa một sốđiều kiện đểtriển khai thuật toán K-Means Clustering. Hãy

xem mã trước:


1 `# Step 3 - Assign all points to the` `nearest` `cluster` `centroid`

2 `# Step 4 - Recalculate` `the` `centroids of the newly` `formed` `clusters`

3 `# Step 5 - Repeat` `steps 3 and 4`


4


5 `diff = 1`


6 `j = 0`


7


8 `while` `diff != 0:`


9 `XD = X.copy ()`


10 `i = 1`


11 `for index1, row_c in Centroids.iterrows ():`


12 `ED = []`


13 `for index2, row_d in XD.iterrows ():`

14 `d1 = (row_c [" ApplicantIncome "] - row_d [" ApplicantIncome "]) **2`

15 `d2 = (row_c [" LoanAmount "] - row_d [" LoanAmount "]) **2`

16 `d = np.sqrt(d1 + d2)`

17 `ED.append(d)`

18 `X[i] = ED`


19 `i += 1`


20


21 `C = []`


22 `for index, row in X.iterrows ():`

23 `min_dist = row [1]`


24 `pos = 1`

25 `for i in range(K):`

26 `if row[i + 1] < min_dist:`


27 `min_dist = row[i + 1]`


28 `pos = i + 1`

29 `C.append(pos)`

30 `X[" Cluster "] = C`

31 `Centroids_new = X.groupby ([" Cluster "]).mean ()[[" LoanAmount", " ApplicantIncome "]]`


32


33 `if j == 0:`


34 `diff = 1`


35 `j += 1`


36 `else:`


37 `diff = (Centroids_new[’LoanAmount ’] - Centroids[’Loan

[page 17] **AI VIETNAM** **aivietnam.edu.vn**


12 `plt.ylabel(’Loan` `Amount (Thousands) ’)`

13 `plt.show ()`


Listing 3: Chọn biến và trực quan hóa dữliệu


**3** **Bước 3: Chọn sốcụm và khởi tạo centroids**


Bước 1 và 2 của K-Means là vềviệc chọn sốlượng cụm (k) và chọn các centroids ngẫu nhiên cho mỗi
cụm. Chúng ta sẽchọn 3 cụm và sau đó chọn các quan sát ngẫu nhiên từdữliệu làm centroids:


1 `# Step 1 and 2 - Choose the number of clusters (k) and` `randomly` `select` `centroids` `for`

```
    each cluster

```

2


3 `# number of clusters`


4 `K = 3`


5


6 `# Randomly` `select` `observations as centroids`

7 `Centroids = X.sample(n=K)`

8 `plt.scatter(X[" ApplicantIncome "], X[" LoanAmount "], c=’black ’)`

9 `plt.scatter(Centroids [" ApplicantIncome "], Centroids [" LoanAmount "], c=’red ’)`

10 `plt.xlabel(’Annual Income ’)`

11 `plt.ylabel(’Loan` `Amount (Thousands) ’)`


Listing 4: Chọn sốcụm và khởi tạo centroids


Ởđây, các chấm đỏđại diện cho 3 centroids của mỗi cụm. Lưu ý rằng chúng ta đã chọn những điểm
này một cách ngẫu nhiên, và do đó mỗi lần bạn chạy mã này, bạn có thểnhận được các centroids khác
nhau.


16

[page 11] _ 34) [2] + (80 _−_ 64) [2] = _√_


Vì _d_ ( _P_ 1 _, C_ 0 ) nhỏnhất, điểm _P_ 1 được gán cho cụm 0. Tiếp tục tương tựcho tất cảđiểm, ta được:



16 + 25 = 6 _._ 4 (7)


144 + 900 = 32 _._ 31 (8)


256 + 256 = 22 _._ 62 (9)



|Index|Tuổi|Chi tiêu|D to C0|D to C1|D to C2|
|---|---|---|---|---|---|
|1<br>2<br>3<br>4<br>5<br>6|18<br>20<br>22<br>30<br>34<br>40|80<br>90<br>85<br>50<br>64<br>60|6.4<br>5.39<br>0.0<br>36.4<br>25.0<br>29.15|32.31<br>42.43<br>35.36<br>0.0<br>14.56<br>14.14|22.62<br>30.41<br>24.17<br>14.56<br>0.0<br>7.21|


Bảng 2: Khoảng cách từcác điểm đến centroids ban đầu


**8.3** **Bước 3: Cập nhật Centroids**


Sau khi gán nhãn, ta tính centroids mới:
**Cụm 0:** Chứa điểm (18,80), (20,90), (22,85)



18 + 20 + 22
_C_ 0 _[new]_ = � 3



3 _,_ [80 + 90 + 85] 3



= (20 _,_ 85)
�



3



**Cụm 1:** Chứa điểm (60,30), (66,40), (70,25), (30,50)



60 + 66 + 70 + 30
_C_ 1 _[new]_ = � 4



4 _,_ [30 + 40 + 25 + 50] 4



= (56 _._ 5 _,_ 36 _._ 25)
�



4



**Cụm 2:** Chứa điểm (34,64), (40,60)



34 + 40
_C_ 2 _[new]_ = � 2



2 _,_ [64 + 60] 2



= (37 _,_ 62)
�



2



**8.4** **Iteration tiếp theo**


Lặp lại quá trình assignment và update cho đến khi centroids không thay

[page 14] ext.fit(bow_matrix.toarray ())`

24 `print` `(` `"Text` `clustering` `labels:"` `, labels)`

## **4. Các kỹthuật nâng cao**


**1** **Lựa chọn K tối ưu - Elbow Method**


1 `def` `elbow_method(X, max_k =10):`

2 `wcss_values = []`

3 `k_range = range` `(1, max_k + 1)`


4


5 `for k in k_range:`

6 `kmeans = KMeans(k=k)`


7 `labels = kmeans.fit(X)`


8 `wcss = calculate_wcss(X, labels, kmeans.centroids)`

9 `wcss_values.append(wcss)`


10


11 `# Plot the Elbow` `graph`

12 `plt.figure(figsize =(10, 6))`

13 `plt.plot(k_range, wcss_values, ’bo -’)`

14 `plt.xlabel(` `’Number of clusters (k)’)`

15 `plt.ylabel(` `’WCSS ’)`

16 `plt.title(` `’Elbow` `Method to select` `optimal k’)`

17 `plt.grid(True)`

18 `plt.show ()`


19


20 `return` `wcss_values`


21


22 `# Use the Elbow` `Method`


23 `wcss_values = elbow_method(X, max_k =8)`


**2** **K-Means++ Initialization**


Cải thiện việc khởi tạo centroids đểtránh local minima:


1 `def` `kmeans_plus_plus_init (X, k):`

2 `centroids = []`


3


4 `# Randomly` `select the first` `centroid`

5 `centroids.append(X[np.random.randint(X.shape [0]) ])`


6


7 `for _ in range` `(1, k):`

8 `# Calculate` `distance to the` `nearest` `centroi

[page 18] 


Listing 5: Triển khai thuật toán K-Means


Những giá trịnày có thểthay đổi mỗi lần chúng ta chạy. Ởđây, chúng ta dừng quá trình huấn luyện
khi các centroids không thay đổi sau hai lần lặp. Đây là tiêu chí hội tụphổbiến nhất được sửdụng cho
thuật toán K-Means clustering. Chúng ta đã định nghĩa diff ban đầu là 1, và bên trong toàn bộvòng
lặp, chúng ta tính toán diff này như là sựkhác biệt giữa các centroids ởlần lặp trước và lần lặp hiện
tại. Khi sựkhác biệt này bằng 0, chúng ta dừng quá trình huấn luyện. **5** **Bước 5: Trực quan hóa kết quả**


Bây giờhãy trực quan hóa các cụm chúng ta đã có được:


17