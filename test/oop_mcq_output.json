{
  "mcqs": {
    "1": {
      "câu hỏi": "Trong ví dụ minh họa lớp Cat, khi gọi cat.describe(2), dòng lệnh `print(self.age)` sẽ in ra giá trị nào?",
      "lựa chọn": {
        "a": "2 (giá trị truyền vào hàm, là biến cục bộ)",
        "b": "1 (giá trị của biến lớp)",
        "c": "Lỗi vì self.age không được định nghĩa",
        "d": "0 (giá trị mặc định của biến toàn cục)"
      },
      "đáp án": "1 (giá trị của biến lớp)"
    },
    "2": {
      "câu hỏi": "Theo nội dung trên, biến nào được mô tả là “thông tin tuyệt mật – chỉ lớp khai báo nó mới có quyền truy cập”?",
      "lựa chọn": {
        "a": "private",
        "b": "protected",
        "c": "public",
        "d": "static"
      },
      "đáp án": "private"
    },
    "3": {
      "câu hỏi": "Biến cục bộ (local variable) trong lập trình hướng đối tượng có đặc điểm nào sau đây?",
      "lựa chọn": {
        "a": "Có thể truy cập ở bất kỳ đâu trong chương trình",
        "b": "Chỉ tồn tại và có thể sử dụng trong một hàm hoặc phương thức cụ thể",
        "c": "Là biến toàn cục được khai báo bên ngoài hàm",
        "d": "Biến được tự động khởi tạo giá trị mặc định"
      },
      "đáp án": "Chỉ tồn tại và có thể sử dụng trong một hàm hoặc phương thức cụ thể"
    },
    "4": {
      "câu hỏi": "Trong lập trình hướng đối tượng, thuộc tính (attributes) của một đối tượng là gì?",
      "lựa chọn": {
        "a": "Các hàm thực hiện hành động của đối tượng",
        "b": "Các biến lưu trữ dữ liệu mô tả đối tượng",
        "c": "Các lớp mà đối tượng kế thừa từ chúng",
        "d": "Các phương thức tĩnh không phụ thuộc vào đối tượng"
      },
      "đáp án": "Các biến lưu trữ dữ liệu mô tả đối tượng"
    },
    "5": {
      "câu hỏi": "Trong Python, phương thức đặc biệt nào cho phép một đối tượng được gọi như một hàm?",
      "lựa chọn": {
        "a": "__init__",
        "b": "__str__",
        "c": "__call__",
        "d": "__len__"
      },
      "đáp án": "__call__"
    }
  },
  "validation": {
    "1": {
      "supported_by_embeddings": true,
      "max_similarity": 1.0644214153289795,
      "evidence": [
        {
          "idx": 1,
          "page": 1,
          "score": 0.6182047724723816,
          "text": "**Biến cục bộ(Local)**\n\n\nBiến cục bộchỉtồn tại và có thểsửdụng trong một hàm hoặc phương thức cụthể. **Quy tắc ưu tiên (Scope resolution):**\n\n\nLocal _>_ Instance _>_ Class _>_ Global (1)\n\n\n**Ví dụminh họa:**\n\n\n1 `class Cat():`\n\n\n2 `age = 1 #Class variabe`\n\n3 `def describe(self, age):`\n\n4 `print(age, age)` `# Ouput: 2,2 (both are local variables)`\n\n5 `print(self.age)` `# Output: 1 (class variable)`\n\n\n6\n\n\n7 `cat = Cat()`\n\n\n8 `cat.describe(2)`\n\n\n1"
        },
        {
          "idx": 2,
          "page": 2,
          "score": 0.9349313378334045,
          "text": "**AI VIETNAM** **aivietnam.edu.vn**\n\n\nCảhai biến age ởlần in đầu tiên đều là biến cục bộvì Python sẽưu tiên tìm biến cục bộtrước,\nởđây là đối số2 truyền vào age. Vì ta không định nghĩa self.age, nên khi gọi, Python sẽtìm đến\nthứtựtiếp theo là biến Class. Chính vì vậy, ta sẽin ra được kết quảage = 1\n\n\n**1.1.2** **Biến toàn cục (Global)**\n\n\nBiến toàn cục được khai báo bên ngoài hàm hoặc class, sửdụng được trên toàn chương trình\nnhưng nên hạn chếđểtránh gây khó kiểm soát. **Không khuyến khích:**\n\n\n1 `counter = 0` `# Global variable`\n\n\n2\n\n\n3 `class MyClass:`\n\n4 `def increment(self):`\n\n\n5 `global counter`\n\n\n6 `counter += 1`\n\n\n**Khuyến khích:**\n\n\n1 `class MyClass:`\n\n\n2 `counter = 0` `# Class attribute`\n\n\n3\n\n\n4 `def increment(self):`\n\n\n5 `MyClass.counter += 1`\n\n### **2 Động lực cho sựra đời của OOP**\n\n\nTrong thực tế, chúng ta luôn tìm cách mô hình hóa các thực thểthực tếthành các đối tượng số\nhóa. Từnhu cầu quản lý và tổchức các thực thểnày, lập trình hướng đối tượng ra đời đểđơn\ngiản hóa và ..."
        },
        {
          "idx": 8,
          "page": 5,
          "score": 1.0644214153289795,
          "text": "es a function →Output: Hi Alice`\n\n\n2. **Stateful function** : Hàm có thểghi nhớtrạng thái bên trong. 1 `class Counter:`\n\n\n2 `def __init__(self):`\n\n\n3 `self.count = 0`\n\n\n4\n\n\n5 `def __call__(self):`\n\n\n6 `self.count += 1`\n\n\n7 `return self.count`\n\n\n8\n\n\n9 `counter = Counter()`\n\n\n10\n\n\n11 `print(counter())` `# 1`\n\n12 `print(counter())` `# 2`\n\n13 `print(counter())` `# 3`\n\n\nMỗi lần gọi `counter()` đều ghi nhớtrạng thái trước đó và cộng dồn lên, không giống như\ncác phương thức thông thường vốn không lưu trạng thái giữa các lần gọi. 3. **Decorator hoặc Callback handler** : (nâng cao cần tìm hiểu thêm). ## **Phần II: Các tính chất cơ bản trong Object-** **Oriented Programming**\n\n### **5** **Delegation (Ủy quyền)**\n\n\nDelegation (ủy quyền) trong lập trình hướng đối tượng là một kỹthuật trong đó một đối tượng\nủy thác trách nhiệm thực hiện một hành vi cụthểcho một đối tượng khác. Thay vì kếthừa trực\n\n\n5"
        }
      ],
      "model_verdict": {
        "supported": true,
        "confidence": 0.99,
        "evidence": "print(self.age) # Output: 1 (class variable)",
        "reason": "Context explicitly states that print(self.age) outputs 1, the class variable."
      }
    },
    "2": {
      "supported_by_embeddings": true,
      "max_similarity": 1.3231226205825806,
      "evidence": [
        {
          "idx": 15,
          "page": 8,
          "score": 1.0267785787582397,
          "text": "p con của nó đều phải **bắt buộc** có phương thức tính diện\ntích. Nếu không, chương trình sẽbáo lỗi. ### **8 Encapsulation (Đóng gói)**\n\n\nTính đóng gói giúp thông tin nội bộcủa đối tượng và chỉcho phép truy cập qua phương thức\ncông khai (public methods). Điều này giúp bảo vệdữliệu và kiểm soát cách dữliệu bịthay đổi. **Ví dụminh họa:**\n\n\n1 `class BankAccount:`\n\n\n2 `def __init__(self, owner, balance):`\n\n\n3 `self.owner = owner`\n\n\n4 `self.__balance = balance` `# \"__\" indicates this is a private attribute`\n\n\n5\n\n\n6 `def deposit(self, amount):`\n\n\n7 `if amount > 0:`\n\n\n8 `self.__balance += amount`\n\n9 `print(f\"Deposited: {amount}\")`\n\n\n10 `else:`\n\n\n11 `print(\"Invalid deposit amount.\")`\n\n\n12\n\n\n13 `def withdraw(self, amount):`\n\n\n14 `if 0 < amount <= self.__balance:`\n\n\n15 `self.__balance -= amount`\n\n\n8"
        },
        {
          "idx": 4,
          "page": 3,
          "score": 1.3231226205825806,
          "text": "**AI VIETNAM** **aivietnam.edu.vn**\n\n\nTương tự:\nGiảsửbạn là một người quản lý thư viện. Trong đó, sách và người đọc chính là những đối tượng\n(objects), còn các quy trình như mượn sách, trảsách, đăng ký thẻđược xem là phương thức\n(methods) – tức là hành vi của các đối tượng. Đểcó thểquản lý hiệu quảtất cảcác đối tượng\nvà hành vi trong hệthống thư viện này, ta cần một cách tổchức logic và linh hoạt. Chính từ\nnhu cầu đó, lập trình hướng đối tượng (OOP) ra đời – như một phương pháp giúp mô hình hóa\nthếgiới thực thành các thành phần trong phần mềm một cách rõ ràng và dễmởrộng.\n\n### **3 Class và Object**\n\n#### **3.1 Class (Lớp)**\n\n\nClass như một bản vẽkỹthuật hoặc template, dùng đểđịnh nghĩa thuộc tính (attributes) và\nphương thức (methods) của các đối tượng.\n\n - **Attributes:** định nghĩa các thông tin, đặc điểm cũng như các thuộc tính của Object.\n\n\n - **Method** : định nghĩa các hành vi, phương thức cũng như các hành động thường có của\nObject\n\n\n3"
        }
      ],
      "model_verdict": {
        "supported": true,
        "confidence": 0.99,
        "evidence": "\"Biến `private` là thông tin tuyệt mật – chỉ lớp khai báo nó mới có quyền truy cập\"",
        "reason": "Context explicitly mô tả biến private như vậy, nên đáp án private được chứng thực."
      }
    },
    "3": {
      "supported_by_embeddings": true,
      "max_similarity": 1.127091884613037,
      "evidence": [
        {
          "idx": 1,
          "page": 1,
          "score": 0.8878949880599976,
          "text": "**Biến cục bộ(Local)**\n\n\nBiến cục bộchỉtồn tại và có thểsửdụng trong một hàm hoặc phương thức cụthể. **Quy tắc ưu tiên (Scope resolution):**\n\n\nLocal _>_ Instance _>_ Class _>_ Global (1)\n\n\n**Ví dụminh họa:**\n\n\n1 `class Cat():`\n\n\n2 `age = 1 #Class variabe`\n\n3 `def describe(self, age):`\n\n4 `print(age, age)` `# Ouput: 2,2 (both are local variables)`\n\n5 `print(self.age)` `# Output: 1 (class variable)`\n\n\n6\n\n\n7 `cat = Cat()`\n\n\n8 `cat.describe(2)`\n\n\n1"
        },
        {
          "idx": 0,
          "page": 1,
          "score": 1.107263207435608,
          "text": "# Tuần 3: Tổng hợp kiến thức buổi học số3 + 4\n\n#### Time-Series Team Ngày 21 tháng 6 năm 2025\n\n\n\n\n## **Phần I: Khái niệm cơ bản vềObject-Oriented** **Programming: Lập trình hướng đối tượng**\n\n### **1** **Giới thiệu vềlập trình hướng đối tượng**\n\nLập trình hướng đối tượng (OOP) là một phương pháp lập trình phổbiến, lấy các đối tượng làm\ntrung tâm đểgiải quyết vấn đềthực tế. Đểhiểu rõ OOP, ta cần nắm các khái niệm cơ bản như\nphạm vi biến, trừu tượng hóa, lớp, đối tượng và các tính chất đặc trưng như kếthừa, đa hình,\nđóng gói và trừu tượng. #### **1.1** **Bước đầu cho OOP - Khái niệm biến local và global (biến cục bộ** **và biến toàn cục)**\n\n\nPhạm vi (scope) biến là yếu tốquan trọng trong lập trình, quyết định nơi một biến có thểtruy\ncập được. **1.1.1** **Biến cục bộ(Local)**\n\n\nBiến cục bộchỉtồn tại và có thểsửdụng trong một hàm hoặc phương thức cụthể."
        },
        {
          "idx": 9,
          "page": 6,
          "score": 1.127091884613037,
          "text": "**AI VIETNAM** **aivietnam.edu.vn**\n\n\ntiếp hoặc xửlý toàn bộlogic nội bộ, đối tượng sẽgọi đến phương thức của một thành phần bên\ntrong đểthực hiện nhiệm vụ. Kỹthuật này giúp tách biệt trách nhiệm giữa các lớp, dễbảo trì\nvà mởrộng hệthống và tăng tính tái sửdụng của mã nguồn."
        }
      ],
      "model_verdict": {
        "supported": true,
        "confidence": 0.99,
        "evidence": "Biến cục bộ chỉ tồn tại và có thể sử dụng trong một hàm hoặc phương thức cụ thể.",
        "reason": "Câu trả lời khớp với mô tả trong Context về đặc điểm của biến cục bộ."
      }
    },
    "4": {
      "supported_by_embeddings": true,
      "max_similarity": 1.02956223487854,
      "evidence": [
        {
          "idx": 5,
          "page": 4,
          "score": 0.7977743148803711,
          "text": "**AI VIETNAM** **aivietnam.edu.vn**\n\n#### **3.2** **Object (Đối tượng)**\n\n\nObject là một thực thểcụthểđược tạo ra từclass, chứa các giá trịthuộc tính cụthểvà khả\nnăng thực hiện các phương thức đã định nghĩa. ### **4 Cách tạo một Class**\n\n\nMột class diagram bao gồm: tên class, attributes, và methods. Sau khi khởi tạo, ta tạo ra một\nobject là instance của class vừa tạo. **Constructor (** **`__init__`** **):** được dùng đểtạo và gán giá trịban đầu cho các thuộc tính (attributes)\ncủa đối tượng.Nói một cách đơn giản, constructor giống như bản thiết kếban đầu giúp ta xác\nđịnh: ”Khi tạo ra một đối tượng mới, nó sẽcó những thông tin gì?”\n\n\n**Self keyword:** Là tham chiếu đến instance cụthểcủa class. **Ví dụ:**\n\n\n1 `class Rectangle:`\n\n2 `def __init__(self, width, height):`\n\n\n3 `self.width = width`\n\n\n4 `self.height = height`\n\n\n5\n\n\n6 `def area(self):`\n\n\n7 `return self.width * self.height`\n\n\n8\n\n\n9 `my_rec = Rectangle(4, 7)`\n\n10 `print(my_rec.area())` `# Output: 28`\n\n\nTa hình dung “self” là một vùn..."
        },
        {
          "idx": 0,
          "page": 1,
          "score": 1.02956223487854,
          "text": "# Tuần 3: Tổng hợp kiến thức buổi học số3 + 4\n\n#### Time-Series Team Ngày 21 tháng 6 năm 2025\n\n\n\n\n## **Phần I: Khái niệm cơ bản vềObject-Oriented** **Programming: Lập trình hướng đối tượng**\n\n### **1** **Giới thiệu vềlập trình hướng đối tượng**\n\nLập trình hướng đối tượng (OOP) là một phương pháp lập trình phổbiến, lấy các đối tượng làm\ntrung tâm đểgiải quyết vấn đềthực tế. Đểhiểu rõ OOP, ta cần nắm các khái niệm cơ bản như\nphạm vi biến, trừu tượng hóa, lớp, đối tượng và các tính chất đặc trưng như kếthừa, đa hình,\nđóng gói và trừu tượng. #### **1.1** **Bước đầu cho OOP - Khái niệm biến local và global (biến cục bộ** **và biến toàn cục)**\n\n\nPhạm vi (scope) biến là yếu tốquan trọng trong lập trình, quyết định nơi một biến có thểtruy\ncập được. **1.1.1** **Biến cục bộ(Local)**\n\n\nBiến cục bộchỉtồn tại và có thểsửdụng trong một hàm hoặc phương thức cụthể."
        }
      ],
      "model_verdict": {
        "supported": true,
        "confidence": 0.98,
        "evidence": "Những thông tin như ngày sinh, giới tính, sốđiện thoại... được xem là thuộc tính (attributes) của người dùng đó.",
        "reason": "Context mô tả thuộc tính là các thông tin dữ liệu mô tả đối tượng, khớp với đáp án."
      }
    },
    "5": {
      "supported_by_embeddings": true,
      "max_similarity": 1.0307352542877197,
      "evidence": [
        {
          "idx": 5,
          "page": 4,
          "score": 0.9137221574783325,
          "text": "**AI VIETNAM** **aivietnam.edu.vn**\n\n#### **3.2** **Object (Đối tượng)**\n\n\nObject là một thực thểcụthểđược tạo ra từclass, chứa các giá trịthuộc tính cụthểvà khả\nnăng thực hiện các phương thức đã định nghĩa. ### **4 Cách tạo một Class**\n\n\nMột class diagram bao gồm: tên class, attributes, và methods. Sau khi khởi tạo, ta tạo ra một\nobject là instance của class vừa tạo. **Constructor (** **`__init__`** **):** được dùng đểtạo và gán giá trịban đầu cho các thuộc tính (attributes)\ncủa đối tượng.Nói một cách đơn giản, constructor giống như bản thiết kếban đầu giúp ta xác\nđịnh: ”Khi tạo ra một đối tượng mới, nó sẽcó những thông tin gì?”\n\n\n**Self keyword:** Là tham chiếu đến instance cụthểcủa class. **Ví dụ:**\n\n\n1 `class Rectangle:`\n\n2 `def __init__(self, width, height):`\n\n\n3 `self.width = width`\n\n\n4 `self.height = height`\n\n\n5\n\n\n6 `def area(self):`\n\n\n7 `return self.width * self.height`\n\n\n8\n\n\n9 `my_rec = Rectangle(4, 7)`\n\n10 `print(my_rec.area())` `# Output: 28`\n\n\nTa hình dung “self” là một vùn..."
        },
        {
          "idx": 3,
          "page": 2,
          "score": 1.0307352542877197,
          "text": "gười dùng chính là một đối tượng (object). Những thông tin như ngày sinh, giới tính, sốđiện thoại... được xem là thuộc tính (attributes)\ncủa người dùng đó. Còn các hành vi như đăng bài, thích (like), chia sẻ(share), bình luận, kết\nbạn... chính là những phương thức (methods) – tức là hành động mà đối tượng đó có thểthực\nhiện. Đây chính là cách mà lập trình hướng đối tượng mô hình hóa và tổchức các thực thểtrong\nthếgiới số. 2"
        }
      ],
      "model_verdict": {
        "supported": true,
        "confidence": 0.99,
        "evidence": "Trong Python, `__call__` là một phương thức đặc biệt ... được sửdụng khi một đối tượng cần hành xử giống như một hàm. Nếu một lớp định nghĩa `__call__`, thì các instance của lớp đó có thể được gọi như một hàm thực sự.",
        "reason": "Context explicitly states that __call__ is the special method allowing objects to be called like functions."
      }
    }
  }
}