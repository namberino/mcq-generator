['[page 18] **AI VIETNAM** **aivietnam.edu.vn**\n\n\n**4** **Bước 4: Triển khai thuật toán K-Means chính**\n\n\nTiếp theo, chúng ta sẽđịnh nghĩa một sốđiều kiện đểtriển khai thuật toán K-Means Clustering.', '[page 17] **AI VIETNAM** **aivietnam.edu.vn**\n\n\n12 `plt.ylabel(’Loan` `Amount (Thousands) ’)`\n\n13 `plt.show ()`\n\n\nListing 3: Chọn biến và trực quan hóa dữliệu\n\n\n**3** **Bước 3: Chọn sốcụm và khởi tạo centroids**\n\n\nBước 1 và 2 của K-Means là vềviệc chọn sốlượng cụm (k) và chọn các centroids ngẫu nhiên cho mỗi\ncụm. Chúng ta sẽchọn 3 cụm và sau đó chọn các quan sát ngẫu nhiên từdữliệu làm centroids:\n\n\n1 `# Step 1 and 2 - Choose the number of clusters (k) and` `randomly` `select` `centroids` `for`\n\n```\n    each cluster\n\n```\n\n2\n\n\n3 `# number of clusters`\n\n\n4 `K = 3`\n\n\n5\n\n\n6 `# Randomly` `select` `observations as centroids`\n\n7 `Centroids = X.sample(n=K)`\n\n8 `plt.scatter(X[" ApplicantIncome "], X[" LoanAmount "], c=’black ’)`\n\n9 `plt.scatter(Centroids [" ApplicantIncome "], Centroids [" LoanAmount "], c=’red ’)`\n\n10 `plt.xlabel(’Annual Income ’)`\n\n11 `plt.ylabel(’Loan` `Amount (Thousands) ’)`\n\n\nListing 4: Chọn sốcụm và khởi tạo centroids\n\n\nỞđây, các chấm đỏđại diện cho 3 centroids của mỗi cụm. Lưu ý rằng chúng ta đã chọn những điểm\nnày một cách ngẫu nhiên, và do đó mỗi lần bạn chạy mã này, bạn có thểnhận được các centroids khác\nnhau.\n\n\n16', '[page 18] ính**\n\n\nTiếp theo, chúng ta sẽđịnh nghĩa một sốđiều kiện đểtriển khai thuật toán K-Means Clustering. Hãy\n\nxem mã trước:\n\n\n1 `# Step 3 - Assign all points to the` `nearest` `cluster` `centroid`\n\n2 `# Step 4 - Recalculate` `the` `centroids of the newly` `formed` `clusters`\n\n3 `# Step 5 - Repeat` `steps 3 and 4`\n\n\n4\n\n\n5 `diff = 1`\n\n\n6 `j = 0`\n\n\n7\n\n\n8 `while` `diff != 0:`\n\n\n9 `XD = X.copy ()`\n\n\n10 `i = 1`\n\n\n11 `for index1, row_c in Centroids.iterrows ():`\n\n\n12 `ED = []`\n\n\n13 `for index2, row_d in XD.iterrows ():`\n\n14 `d1 = (row_c [" ApplicantIncome "] - row_d [" ApplicantIncome "]) **2`\n\n15 `d2 = (row_c [" LoanAmount "] - row_d [" LoanAmount "]) **2`\n\n16 `d = np.sqrt(d1 + d2)`\n\n17 `ED.append(d)`\n\n18 `X[i] = ED`\n\n\n19 `i += 1`\n\n\n20\n\n\n21 `C = []`\n\n\n22 `for index, row in X.iterrows ():`\n\n23 `min_dist = row [1]`\n\n\n24 `pos = 1`\n\n25 `for i in range(K):`\n\n26 `if row[i + 1] < min_dist:`\n\n\n27 `min_dist = row[i + 1]`\n\n\n28 `pos = i + 1`\n\n29 `C.append(pos)`\n\n30 `X[" Cluster "] = C`\n\n31 `Centroids_new = X.groupby ([" Cluster "]).mean ()[[" LoanAmount", " ApplicantIncome "]]`\n\n\n32\n\n\n33 `if j == 0:`\n\n\n34 `diff = 1`\n\n\n35 `j += 1`\n\n\n36 `else:`\n\n\n37 `diff = (Centroids_new[’LoanAmount ’] - Centroids[’Loan', '[page 9] **AI VIETNAM** **aivietnam.edu.vn**\n\n\nvà nợcao, trong khi cụm xanh có thu nhập cao nhưng nợthấp. Rõ ràng cụm phân chia trong trường\nhợp II hợp lý hơn. Như vậy, các điểm dữliệu từcác cụm khác nhau nên khác biệt nhiều nhất có thểđểtạo thành các\ncụm có ý nghĩa hơn. Thuật toán K-means dùng phương pháp lặp đểtìm phân cụm tối ưu bằng cách\ngiảm thiểu tổng bình phương khoảng cách giữa các điểm và centroid của cụm. **5.3** **Tại sao chúng ta cần phân cụm?**\n\n\nChúng ta đã hiểu phân cụm là gì và các thuộc tính khác nhau của cụm. Vậy tại sao phải dùng phân\ncụm? Phần tiếp theo sẽgiải đáp thắc mắc này và giới thiệu một sốứng dụng thực tế. **6** **Ứng dụng của phân cụm trong thực tế**\n\n\nPhân cụm được sửdụng rộng rãi trong nhiều lĩnh vực, từngân hàng, hệthống đềxuất, đến phân cụm\nvăn bản và phân đoạn ảnh. - **Phân đoạn khách hàng:** Đây là ứng dụng phổbiến nhất của phân cụm, không chỉtrong ngân\nhàng mà còn trong viễn thông, thương mại điện tử, thểthao, quảng cáo, bán hàng,... - **Phân cụm văn bản:** Nếu bạn có nhiều tài liệu và muốn nhóm các tài liệu tương tựlại với nhau,\nphân cụm giúp gom các tài liệu giống nhau vào cùng một nhóm.', '[page 7] **AI VIETNAM** **aivietnam.edu.vn**\n\n\n**5** **Các thuộc tính của thuật toán K-means Clustering**\n\n\nHãy xem một ví dụkhác vềthuật toán phân cụm K-means. Chúng ta sẽdùng ví dụvềmột ngân hàng\nmuốn phân đoạn khách hàng của mình. Đểđơn giản, giảsửngân hàng chỉdùng thu nhập và nợđể\nphân nhóm khách hàng. Họthu thập dữliệu khách hàng và dùng biểu đồphân tán đểtrực quan hóa:\nTrục X thểhiện thu nhập khách hàng, trục Y là sốtiền nợ. Ởđây, chúng ta có thểdễdàng nhận\nthấy khách hàng được phân thành 4 nhóm khác nhau, như hình dưới:\nĐây chính là cách clustering (phân cụm) giúp tạo ra các nhóm (cụm) từdữliệu. Ngân hàng có thể\ndùng các cụm này đểxây dựng chiến lược và đưa ra ưu đãi cho khách hàng. Bây giờhãy cùng tìm hiểu\ncác thuộc tính của các cụm này. **5.1** **Thuộc tính thứnhất của thuật toán K-means**\n\n\nTất cảcác điểm dữliệu trong một cụm nên có tính tương đồng với nhau. Ví dụvới trường hợp trên:\nNếu khách hàng trong một cụm không giống nhau, thì nhu cầu của họcũng khác nhau, đúng không? Nếu ngân hàng áp dụng cùng một chương trình ưu đãi cho tất cảkhách hàng đó, có thểhọsẽkhông\nhài lòng, và sựquan tâm đến ngân hàng sẽgiảm đi. Điều này không lý tưởng.']